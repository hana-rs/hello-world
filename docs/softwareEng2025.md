---
layout: page
title: "software Eng. lecture note
permalink: /docs/softwareEng2025
---


# ソフトウェア工学の内容まとめ
## 第1回
### ガイダンス
#### 到達目標
ソフトウェア・エンジニアリングの基礎知識の理解及び実務的なスキルの習得を目標とする。

#### 講義の狙い
ソフトウェア工学の知見を考える機会提供。

#### 内容
ソフトウェア工学を学ぶ上でのむずかしさ(例えば、実際に携わった経験がなければイメージがわかないことや、知見と実践の乖離、個々人のソフトウェア工学の知識だけでは不十分であるということ)

またLLMなどAIがソフトウェアを開発する時代において、要件定義、バージョン管理、テストなど監督者として不可欠なソフトウェア工学の能力が求められるということ。


## 第2回
### ソフトウェア工学概論

#### ソフトウェアとは
- 実行されることによって必要な特性、機能、性能を提供する命令語群(コンピュータプログラム)
- プログラムが適切に情報を扱うことを可能とするデータ構造
- プログラムの操作や使用法を記述した情報
- ハードウェアと異なり、劣化はしないが悪化はするもの

#### ソフトウェアの特徴
- 新しい環境や技術のニーズを満たすよう適応しなければならない
- 新しいビジネス要求を実現するために強化されなければならない
- より近代的なシステムやデータベースと相互運用するため拡張されなければならない
- 進化し続ける環境で実行可能となるよう、再構築されなければならない

#### プラクティスの本質
- 問題を理解する(コミュニケーションと分析)
- 解決策を計画する(モデリングとソフトウェア設計)
- 計画を実行に移す(コード実装)
- 結果が正しいことを理解する(テストと品質保証)

#### Hookerの7原則
- システムが存在する唯一の理由(システムはユーザーに価値を提供するためにある)
- シンプルにしておけ(すべての設計は可能な限りシンプルであるべき)
- ビジョンを持ち続けよ(ソフトウェアプロジェクトの成功には明確なビジョンが不可欠である)
- あなたの作ったものをほかの人が使用する(あなたのやっていることを他人が理解しなければならないということを常に考えながら仕様を決め、設計し、ドキュメントを書き、実装するべきである。)
- 未来へオープンであれ(コンピュータ環境の仕様変更に対応すべく、一般的な問題を解決するシステムを構築して、可能な限り多くの選択肢を与えられるよう準備しておく)
- 再利用に先駆けて計画せよ(コストを低減し、再利用するコンポーネントと、それを取り込むシステムの両方の価値を高める)
- 考えよ！(行動を起こす前に簡潔明瞭な考えをもつことは、必ずと行ってよいほどよい結果を生む)

#### ソフトウェア工学とは
品質、コスト、納期の最適なバランスを実現するための手法、方法論。

#### ソフトウェア工学の必要性
- 大規模化と複雑さ
- IT人材の不足
- 社会性と求められるミッション
- 不確実性の増大

#### ソフトウェア工学とプログラミングの違い
- 時間(プログラムの想定稼働時間や、依存するライブラリ・OS・ハードウェアへの対処といった時間の視点がいる)
- スケール(開発・保守作業の規模拡大や、対応する人員のスケーリングを考える必要がある)
- 時間・スケールのトレードオフ(時間・スケールの最大化)

#### Hyrumの法則
「あるAPIに十分な数のユーザーがいるとき、APIを作った者自身が契約仕様として何を約束しているかは重要ではない。作られたシステムが持つあらゆる観察可能(observable)な挙動に関して、それに依存するユーザーが出てくるものである」という法則。

→ユーザーは、開発者の意図しない方法を含め、ソフトウェアの自由な使い方が可能。


## 第3回
### ソフトウェアライフサイクル
#### ソフトウェアライフサイクル
ソフトウェアの誕生、開発・運用、廃止という一連の流れのこと。

#### 要件定義
- システムの目的、概要、機能、構成などを定義する。
- 実現する機能、しない機能を明確にすることが重要。
- 要件定義の意義として、プロジェクト関係者のバイブルや、社内外への協力依頼、RFPなどがある。

#### 設計
- WBSなど、要件定義書から設計書へ、コーディングができるレベルの仕様書に落とし込むこと。

#### 制作
- 設計書に従ってシステム構築
- 内製と調達の二種類がある
- 調達の場合、ソースコードを納品物に含めない場合は、メンテナンスについて、作業委託契約締結が必要

#### オフショア開発
- 賃金の安い海外企業に外部委託する手法
- 文化や言語、習慣、意識の違い等に注意が必要

#### テストとデバッグ
- あらかじめテストをしてバグの早期発見・対処をすることが理想
- どの箇所をどの程度テストするのか工数を考えながら判断

#### 運用保守
- 稼働後のデータをプロアクティブに活用するべき
- ソフトウェア以外の要因も考慮する必要がある
- 開発者はすでにプロジェクトから離れている可能性もある

#### ドキュメンテーション
- 複数人でのソフトウェアの開発において、非同期コミュニケーションは重要
- IT技術のほとんどが海外産であることや、海外企業とのプロジェクトの可能性など、文書が日本語とは限らない


## 第4回
### プロジェクト
#### プロジェクトとは
- 有期性(必ず終わりのある仕事)
- 独自性(独自の目的を達成する類の仕事)

#### フォアキャスティング・バックキャスティング
- フォアキャスティングとは、インプット視点で、今の立ち位置から順に目標に進んでいくアプローチのこと。目標に達成できない可能性や、目標と遠いところに到達する可能性がある。
- バックキャスティングとは、アウトプット視点で、定めた目標に向けて何が必要かを計画し達成に向かうアプローチのこと。目標を明確に設定する必要があり、目標に向けての筋道を検討する必要があるが修正は適宜可能である。プロジェクト業務はこの考え方に基づいている。

### ソフトウェア分析
#### ソフトウェア分析とは
- ソフトウェアの物量に関する分析
- ソフトウェアの実行性能に関する分析
- ソフトウェアの開発工数に関する分析
- ソフトウェアの品質に関する分析

これらの分析はQCDの管理に使用される。

#### QCDの優先度
QCDの優先度はその特性により異なる。

人命に影響があるシステムは品質優先、公共関連のシステムは費用優先、イベント行事関連システムは納期が優先される。

#### ソフトウェアの評価
ソフトウェアの評価はステップ数とオブジェクト容量で決まる。
また、ファンクションポイント法と呼ばれる方法でも評価できる。
さらに、視認性や操作性など使い勝手の良さも評価対象である。

### 開発プロセス
#### ウォーターフォール型開発プロセス
『要件定義→機能設計→詳細設計→プログラム制作→単体テスト→組み合わせテスト→総合テスト』
のように、工程を上から下へ順に進める開発手法。

進捗管理が容易で、成果物が明確だが、後工程にしわ寄せが集中するというリスクがある。
#### スパイラルモデル
プログラム開発を小さなフェーズに分割し、『提案しプロトタイプを作り評価してフィードバックする』という流れを繰り返しながら開発を進める。

プロトタイプ作成に想定外の作業量が発生するリスクがある。
#### 反復型開発プロセス
ソフトウェアを機能分割し、これを「反復」と呼ばれる単位で管理する方式。

顧客の要求を取り入れやすく、部分的な納品ができるメリットがあるが、管理業務が増え、全体像が見えにくくなるデメリットがある。
#### アジャイルプロセス

変化に対応して無駄を廃し、最適な手法で動くソフトウェアの提供を優先する手法。

- プロセスやツールよりも、個人や相互作用を優先
- 分かりやすいドキュメントよりも動くソフトウェアを優先
- 契約上の駆け引きよりも顧客とのコラボレーションを優先
- 計画を硬直的に守るよりも、変化への対応を優先

アジャイル開発には、開発をする上で心がけるべき12の原則が存在する。

#### 結論
どの開発手法も一長一短であり、場面や要求によって使い分けるべき。

#### リスク駆動型開発プロセス
想定されるリスクを予め把握すること。

- アジャイル(人的リスク)
- 計画駆動型(技術的課題、規模拡大・縮小)
- アジャイル・計画駆動型共通(ニーズの変化、政治的要因、社会的要因)
- 予測不可能なリスク(天才、メンバーの事故・病気、開発環境がクラッシュ)



## 第5・6回
### WBS
#### WBSとは
 プロジェクト目標を達成し、必要な要素成果物を生成するために、プロジェクトチームが実行する作業を、要素成果物を主体に階層的に要素分解したもの。

 プロジェクトを細かな作業（Work）に分解（Breakdown）した構成図（Structure）

#### WBSのメリット
- スコープが明確になる
- 作業を洗い出し明確にする
- 全体管理と作業計画が明確化される

#### WBSの作り方
- トップダウンやバックキャスティングのアプローチでスコープを明確に定義する
- 大きな作業をグルーピングする
- グルーピングした作業の相互関連を考え、作業の前後関係を定義する
- もれなくだぶりなく、各グループの作業を洗い出す

## 第7回
### コーディング
 読みやすいコードを書くことは重要である。
 PythonにはPEP8と呼ばれるコーディング規約がある。

### PEP8
#### コードのレイアウト
- 1行の長さは79文字以内にする
- docstringやコメントは72文字以内にする
- 行を継続する場合は、折り返された要素を縦に揃える(Hanging indentation)
- 1レベルインデントするごとに、スペースを4つ使う

#### スペース
- 演算子の前後にスペースを前後に一つずつ空ける
- 無駄なスペースを入れない

#### 改行
- 改行して、文を重ねない
- 演算子の位置を揃える

#### import
- 1.標準ライブラリ
- 2.サードパーティに関連するもの
- 3.ローカルなアプリケーション/ライブラリに特有のもの

#### コメント
- コードを変更した際はコメントを最新にする
- コメントは複数の完全な文で書く
- コメントが2つ以上の文からなる場合、文の終わりのピリオドのあとは、二つスペースを入れるべき
- できるだけ英語で書く

#### 命令規則
- パッケージ: すべて小文字の短い名前(アンダースコアなし)
- モジュール: すべて小文字の短い名前(アンダースコアで区切っても良い)
- クラス、例外: CapWords方式
- 関数、メソッド: 小文字のみ、必要に応じて単語をアンダースコアで区切る
- 定数: 大文字のみ、単語をアンダースコアで区切る(通常、モジュールレベルに書く)
- 変数、引数: 小文字のみ、必要に応じて単語をアンダースコアで区切る
- 1文字変数: l,p,Iは決して使わない

#### その他
- UTF-8以外のエンコーディングは可能な限り使わない
- ASCII文字以外の使用を極力避ける（日本語も！）
- PEP8のスタイルガイドに合わせることは重要だが、プロジェクトの中で一貫性を保つことはもっと重要

## Linter
チェックツールのこと。
- flake8: pep8に基づくコードチェックツール
- pylint: vscodeのデフォルト


## 第8回
### バージョン管理
ファイルを誰がいつどのように変更したかを管理する。
これらの情報が管理されていれば、共同開発ができる。
- 集中管理型: Subversionなど
- 分散管理型: gitなど

#### 集中管理型
- 同時編集をするとコンフリクトが発生しやすい
- 同期に時間がかかる

#### 分散管理型
- リモートリポジトリへのアクセス頻度が低い
- 障害に頑健

### git
分散管理型のバージョン管理システム。
変更履歴が残り、変更した箇所に戻ることができる。
また、他人と共同編集できる。

#### コミット
ファイル作成・変更・削除の記録のこと。
対象ファイルは一つでも複数でもよく、コミットの単位はユーザーが自由に決定することができる。

#### レポジトリ
gitが管理するプロジェクトのフォルダのこと。
- ローカルレポジトリ: 個々のプロジェクトの実行環境
- リモートレポジトリ: 共同の管理場所

### ローカルレポジトリでの流れ
3つのエリアで作業を進めることができる。
#### ワークツリー
実際にファイルを編集する場所
#### ステージングエリア
コミットした変更内容を```git add```コマンドでステージングする場所
#### Gitディレクトリ
```git commit```コマンドで記録し、変更履歴として保存する場所

### ブランチ
作業履歴を分離させる機能。
メインのコードに影響を与えず、新機能の開発やバグ修正などの作業を並行して進めることができる。

## 第10回
### gitコマンド(設定・確認系)
- ```git init```: gitの初期化・設定開始
- ```git status```: ワークツリーのステータスを表示
- ```git config```: 設定周りの確認・変更
- ```git log```: ログを表示(```-- oneline```でコミットメッセージの1行のみの一覧表示)
- ```git diff```: ファイルの差分を表示

### gitコマンド(コミット系)
- ```git add```: ステージングエリアに追加
- ```git commit```: コミットの実行

### gitコマンド(修正系)
- ```git commit --amend```: コミットの修正
- ```git checkout```: 削除されたファイルを復旧や過去コミットの復元など（元に戻す変更がstaging area/index内にある場合）
- ```git reset```: コミットのリセット
- ```git revert```: 「コミットの変更を打ち消す」コミット
- ```git rm```: ファイルとindex情報の削除

### gitコマンド(リモート系)
- ```git clone```: レポジトリをコピー
- ```git pull```: リモートレポジトリの同期
- ```git push```: 変更をアップロードする
- ```git request-pull```: プルリクエスト:変更依頼
- ```git remote```: リモートレポジトリの設定

### gitコマンド(ブランチ系)
- ```git branch```: ブランチの作成
- ```git checkout```: ブランチの切り替え
- ```git merge```: ブランチの統合
- ```git clone```: レポジトリのコピー
- ```git push```: 変更をアップロードする

## 第11回
### GitHub
- リモートレポジトリのホスティングサービスの一つ。

### GitHubでのソフトウェア・エンジニアリング
#### clone/fork
他のユーザーのリポジトリを自分のアカウントにコピーする```fork```を行い、それを自分のローカルPCに```clone```することで、元のリポジトリに影響を与えず開発を始めることができる。

#### issues
レポジトリに関する問題・課題・バグ・機能追加や質問をあげるための機能

#### projects
issuesなどを管理するためのテーブル

## 第12回
### CI/CD
#### Continuous Integration(CI)
コード変更を共有リポジトリに頻繁に統合するプロセス。
自動テストとビルドを定期的に実行し、バグの早期発見と修正を可能にする。
CIの自動化により、開発のスムーズな進行を促進する。

#### Continues Delivery(CD)
コード変更をテスト環境や本番環境に自動的にデプロイするプロセス。
自動デプロイメントを組み込み、手動操作によるデプロイの必要性を排除する。
CDにより、ユーザーフィードバックを迅速に反映可能。

### CI/CDパイプラインの基本的なステップ
1. ソース: コード変更をトリガーにワークフローを起動
2. ビルド: ソースコードをコンパイル
3. テスト: 自動テストを実行
4. デプロイ: テスト済みのコードを本番環境にデプロイ
5. 検証: デプロイされたアプリケーションの動作確認
6. モニタリング: 本番環境での継続的な監視

### GitHub Actionsを使用したCI/CD
1. ワークフローの定義: YAMLファイルで定義し、 .github/workflows/ディレクトリに配置. イベント、ジョブ、ステップで構成
2. トリガー: プッシュ、プルリクエスト、スケジュールなど様々なイベントでワークフローを起動可能
3. ジョブとステップ: ジョブは並列実行が可能. ステップでは、シェルコマンドの実行やアクションの使用が可能
4. アクション: 再利用可能なワークフローの構成要素. コミュニティが作成したアクションも利用可能
5. ランナー: GitHub提供のホステッドランナーまたはセルフホステッドランナーを使用可能

## 第13回
### GitHub Pages
GitHubにあるリモートレポジトリの内容をWebpageとして公開することができる。
- HP更改はCI/CDにより自動化
- Jekyllを使用することでmarkdownファイルを自動でhtml化することができる
